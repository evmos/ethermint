import { Writer, Reader } from "protobufjs/minimal";
export declare const protobufPackage = "ethermint.evm.v1alpha1";
/** Params defines the EVM module parameters */
export interface Params {
    /**
     * evm_denom represents the token denomination used to run the EVM state
     * transitions.
     */
    evmDenom: string;
    /** enable_create toggles state transitions that use the vm.Create function */
    enableCreate: boolean;
    /** enable_call toggles state transitions that use the vm.Call function */
    enableCall: boolean;
    /** extra_eips defines the additional EIPs for the vm.Config */
    extraEips: number[];
}
/**
 * ChainConfig defines the Ethereum ChainConfig parameters using sdk.Int values
 * instead of big.Int.
 *
 * NOTE 1: Since empty/uninitialized Ints (i.e with a nil big.Int value) are
 * parsed to zero, we need to manually specify that negative Int values will be
 * considered as nil. See getBlockValue for reference.
 *
 * NOTE 2: This type is not a configurable Param since the SDK does not allow
 * for validation against a previous stored parameter values or the current
 * block height (retrieved from context). If you want to update the config
 * values, use an software upgrade procedure.
 */
export interface ChainConfig {
    /** Homestead switch block (< 0 no fork, 0 = already homestead) */
    homesteadBlock: string;
    /** TheDAO hard-fork switch block (< 0 no fork) */
    daoForkBlock: string;
    /** Whether the nodes supports or opposes the DAO hard-fork */
    daoForkSupport: boolean;
    /**
     * EIP150 implements the Gas price changes
     * (https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (< 0 no fork)
     */
    eip150Block: string;
    /** EIP150 HF hash (needed for header only clients as only gas pricing changed) */
    eip150Hash: string;
    /** EIP155Block HF block */
    eip155Block: string;
    /** EIP158 HF block */
    eip158Block: string;
    /** Byzantium switch block (< 0 no fork, 0 = already on byzantium) */
    byzantiumBlock: string;
    /** Constantinople switch block (< 0 no fork, 0 = already activated) */
    constantinopleBlock: string;
    /** Petersburg switch block (< 0 same as Constantinople) */
    petersburgBlock: string;
    /** Istanbul switch block (< 0 no fork, 0 = already on istanbul) */
    istanbulBlock: string;
    /** Eip-2384 (bomb delay) switch block (< 0 no fork, 0 = already activated) */
    muirGlacierBlock: string;
    /** YOLO v3: Gas repricings */
    yoloV3Block: string;
    /** EWASM switch block (< 0 no fork, 0 = already activated) */
    ewasmBlock: string;
    /** Catalyst switch block (< 0 = no fork, 0 = already on catalyst) */
    catalystBlock: string;
}
/** State represents a single Storage key value pair item. */
export interface State {
    key: string;
    value: string;
}
/**
 * TransactionLogs define the logs generated from a transaction execution
 * with a given hash. It it used for import/export data as transactions are not
 * persisted on blockchain state after an upgrade.
 */
export interface TransactionLogs {
    hash: string;
    logs: Log[];
}
/**
 * Log represents an protobuf compatible Ethereum Log that defines a contract
 * log event. These events are generated by the LOG opcode and stored/indexed by
 * the node.
 */
export interface Log {
    /** address of the contract that generated the event */
    address: string;
    /** list of topics provided by the contract. */
    topics: string[];
    /** supplied by the contract, usually ABI-encoded */
    data: Uint8Array;
    /** block in which the transaction was included */
    blockNumber: number;
    /** hash of the transaction */
    txHash: string;
    /** index of the transaction in the block */
    txIndex: number;
    /** hash of the block in which the transaction was included */
    blockHash: string;
    /** index of the log in the block */
    index: number;
    /**
     * The Removed field is true if this log was reverted due to a chain
     * reorganisation. You must pay attention to this field if you receive logs
     * through a filter query.
     */
    removed: boolean;
}
/** TxReceipt defines the receipt type stored in KV for each EVM transaction. */
export interface TxReceipt {
    hash: string;
    from: string;
    data: TxData | undefined;
    result: TxResult | undefined;
    index: number;
    blockHeight: number;
    blockHash: string;
}
/** TxResult stores results of Tx execution. */
export interface TxResult {
    /**
     * contract_address contains the ethereum address of the created contract (if
     * any). If the state transition is an evm.Call, the contract address will be
     * empty.
     */
    contractAddress: string;
    /** bloom represents the bloom filter bytes */
    bloom: Uint8Array;
    /**
     * tx_logs contains the transaction hash and the proto-compatible ethereum
     * logs.
     */
    txLogs: TransactionLogs | undefined;
    /** ret defines the bytes from the execution. */
    ret: Uint8Array;
    /** reverted flag is set to true when the call has been reverted */
    reverted: boolean;
    /** gas_used notes the amount of gas consumed while execution */
    gasUsed: number;
}
/**
 * TxData implements the Ethereum transaction data structure. It is used
 * solely as intended in Ethereum abiding by the protocol.
 */
export interface TxData {
    /** destination EVM chain ID */
    chainId: Uint8Array;
    /** nonce corresponds to the account nonce (transaction sequence). */
    nonce: number;
    /** price defines the unsigned integer value of the gas price in bytes. */
    gasPrice: Uint8Array;
    /** gas defines the gas limit defined for the transaction. */
    gas: number;
    /** hex formatted address of the recipient */
    to: string;
    /** value defines the unsigned integer value of the transaction amount. */
    value: Uint8Array;
    /** input defines the data payload bytes of the transaction. */
    input: Uint8Array;
    accesses: AccessTuple[];
    /** v defines the signature value */
    v: Uint8Array;
    /** r defines the signature value */
    r: Uint8Array;
    /** s define the signature value */
    s: Uint8Array;
}
export interface BytesList {
    bytes: Uint8Array[];
}
/** AccessTuple is the element type of an access list. */
export interface AccessTuple {
    /** hex formatted ethereum address */
    address: string;
    /** hex formatted hashes of the storage keys */
    storageKeys: string[];
}
export declare const Params: {
    encode(message: Params, writer?: Writer): Writer;
    decode(input: Reader | Uint8Array, length?: number): Params;
    fromJSON(object: any): Params;
    toJSON(message: Params): unknown;
    fromPartial(object: DeepPartial<Params>): Params;
};
export declare const ChainConfig: {
    encode(message: ChainConfig, writer?: Writer): Writer;
    decode(input: Reader | Uint8Array, length?: number): ChainConfig;
    fromJSON(object: any): ChainConfig;
    toJSON(message: ChainConfig): unknown;
    fromPartial(object: DeepPartial<ChainConfig>): ChainConfig;
};
export declare const State: {
    encode(message: State, writer?: Writer): Writer;
    decode(input: Reader | Uint8Array, length?: number): State;
    fromJSON(object: any): State;
    toJSON(message: State): unknown;
    fromPartial(object: DeepPartial<State>): State;
};
export declare const TransactionLogs: {
    encode(message: TransactionLogs, writer?: Writer): Writer;
    decode(input: Reader | Uint8Array, length?: number): TransactionLogs;
    fromJSON(object: any): TransactionLogs;
    toJSON(message: TransactionLogs): unknown;
    fromPartial(object: DeepPartial<TransactionLogs>): TransactionLogs;
};
export declare const Log: {
    encode(message: Log, writer?: Writer): Writer;
    decode(input: Reader | Uint8Array, length?: number): Log;
    fromJSON(object: any): Log;
    toJSON(message: Log): unknown;
    fromPartial(object: DeepPartial<Log>): Log;
};
export declare const TxReceipt: {
    encode(message: TxReceipt, writer?: Writer): Writer;
    decode(input: Reader | Uint8Array, length?: number): TxReceipt;
    fromJSON(object: any): TxReceipt;
    toJSON(message: TxReceipt): unknown;
    fromPartial(object: DeepPartial<TxReceipt>): TxReceipt;
};
export declare const TxResult: {
    encode(message: TxResult, writer?: Writer): Writer;
    decode(input: Reader | Uint8Array, length?: number): TxResult;
    fromJSON(object: any): TxResult;
    toJSON(message: TxResult): unknown;
    fromPartial(object: DeepPartial<TxResult>): TxResult;
};
export declare const TxData: {
    encode(message: TxData, writer?: Writer): Writer;
    decode(input: Reader | Uint8Array, length?: number): TxData;
    fromJSON(object: any): TxData;
    toJSON(message: TxData): unknown;
    fromPartial(object: DeepPartial<TxData>): TxData;
};
export declare const BytesList: {
    encode(message: BytesList, writer?: Writer): Writer;
    decode(input: Reader | Uint8Array, length?: number): BytesList;
    fromJSON(object: any): BytesList;
    toJSON(message: BytesList): unknown;
    fromPartial(object: DeepPartial<BytesList>): BytesList;
};
export declare const AccessTuple: {
    encode(message: AccessTuple, writer?: Writer): Writer;
    decode(input: Reader | Uint8Array, length?: number): AccessTuple;
    fromJSON(object: any): AccessTuple;
    toJSON(message: AccessTuple): unknown;
    fromPartial(object: DeepPartial<AccessTuple>): AccessTuple;
};
declare type Builtin = Date | Function | Uint8Array | string | number | undefined;
export declare type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export {};
